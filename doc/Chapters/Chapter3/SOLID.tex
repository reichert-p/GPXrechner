\section{Kapitel 3: SOLID}

\subsection{Analyse Single-Responsibility-Principle (SRP)}

\subsubsection{Positiv-Beispiel}
 
Die Klasse Latitude und repräsentiert eine Breite im Sexalsystem. Die einzige Aufgabe ist die Korrekte Repräsentation dieser Breite.

\begin{figure}[h]
  \centering
  \includesvg[inkscapelatex = false, scale = 1]{Chapters/Chapter3/SRP_good}
  \caption{UML Diagramm der Klasse Latitude}
\end{figure}

\subsubsection{Negativ-Beispiel}

Die Klasse SpeedCalculator implementiert Berechnungen mit Geschwindigkeiten.
Zwei der öffentlichen Methoden berechnen die Bewegungsgeschwindigkeit (Zusammengesetzt aus horizontaler, auf- und absteigender Geschwindigkeit) aus einer oder mehrerer begangener Touren. Eine weitere die relative Geschwindigkeit zweier Touren zueinander (Dies wird benötigt um Geschwindigkeit-Zeit-Diagramme zu erstellen).
Die Klasse hat also zwei Aufgaben.

\begin{figure}[h]
 \label{fig:shitSRP}
  \centering
  \includesvg[inkscapelatex = false, scale = 1]{Chapters/Chapter3/SRP_bad}
  \caption{UML Diagramm der Klasse SpeedCalculator}
\end{figure}



Um hier das Single-Responsibility-Principle umzusetzen könnte die Klasse aufgeteilt werden. Dadurch entstünden zwei neuen Klassen, welche jeweils nur eine Abhängigkeit hätten, wie Abbildung \ref{fig:betterSRP} zeigt.

\begin{figure}[h]
  \label{fig:betterSRP}
  \centering
  \includesvg[inkscapelatex = false, scale = 1]{Chapters/Chapter3/SRP_better}
  \caption{Abbildung \ref{fig:shitSRP} mit umgesetzten SRP}
\end{figure}

\subsection{Analyse Open-Closed-Principle (OCP)}

\subsubsection{Positiv-Beispiel}

Ein Beispiel für die Anwendung des Open-Closed-Prinzips (OCP) findet sich im Instruction Interface. Dieses Interface bildet den zentralen Punkt in der Anwendungslogik der Anwendungsschicht.
Implementierungen des Interfaces implementieren die Logik für verschiedene Anwendungsfälle.
Die execute() Methode startet den entsprechenden Anwendungsfall aus.
Durch die Umsetzung mithilfe des Instruction Interfaces können neue Anwendungsfälle problemlos hinzugefügt werden, ohne bestehende Befehle zu verändern.

\begin{figure}[H]
  \centering
  \includesvg[inkscapelatex = false, scale = 1]{Chapters/Chapter3/OCP_good}
  \caption{UML Diagramm des Instruction Interfaces mit 2 beispielhaften Implementierungen}
\end{figure}

\subsubsection{Negativ-Beispiel}

Das Open-Closed-Prinzip (OCP) wird bei der Umsetzung des Programmflusses, der die Reihenfolge der wählbaren Anweisungen bestimmt, verletzt. Hierbei wird lediglich die Klasse Console implementiert und aufgerufen. Um dies auf eine andere Weise umzusetzen, beispielsweise mit Hilfe von Event Listenern oder um den Aufruf von "unsinnigen" Anweisungen zu vermeiden, müsste die bestehende Implementierung in der Klasse Console geändert werden.

\begin{figure}[H]
  \centering
  \includesvg[inkscapelatex = false, scale = 1]{Chapters/Chapter3/OCP_bad}
  \caption{UML Diagramm der Klasse SpeedCalculator}
\end{figure}

Mithilfe eines ProgramFlow Interfaces könnte hier das OCP verwendet werden.
Dadurch wäre es möglich, alternative Implementierungen als Implementierung des ProgramFlow Interfaces umzusetzen, ohne die bestehende Console Klasse zu ändern. Dies ermöglicht eine flexible Erweiterung des Programmflusses, ohne bestehenden Code zu modifizieren.
\begin{figure}[H]
  \centering
  \includesvg[inkscapelatex = false, scale = 1]{Chapters/Chapter3/OCP_better}
  \caption{UML Diagramm mit Umsetzung des SRP}
\end{figure}


\subsection{Dependency-Inversion-Principle (DIP))}

\subsubsection{Positiv-Beispiel}

Das Dependency Inversion Principle wurde bei der Implementierung der TimePrediction angewendet, um zu verhindern, dass diese von den Details eines bestimmten Pfades abhängig ist. Durch die Verwendung des Path Interfaces ist die Detailimplementierung (Track) nun von der Abstraktion (Path) entkoppelt. Das bedeutet, dass verschiedene Implementierungen von Path verwendet werden können, ohne Änderungen an der TimePrediction-Klasse vornehmen zu müssen. Dies ermöglicht eine flexible Gestaltung der Software mit reduzierten Abhängigkeiten von konkreten Implementierungen.

\begin{figure}[H]
  \centering
  \includesvg[inkscapelatex = false, scale = 0.5]{Chapters/Chapter3/TimePrediction}
  \caption{Dependency Inversion bei Zeitvorhersagen von verschiedenen Arten von Pfaden}
\end{figure}

\subsubsection{Negativ-Beispiel}

Das Dependency-Inversion-Principle wird beim Zugriff auf die Klasse GPXToTour verletzt, die aus GPX Dateien ein Tour Objekt generiert.
Sie ist eine Implementation des XMLParser Interfaces. Die Instruction ReadPath verwendet aber diese konkrete Implementierung anstelle des allgemeinen Interfaces, da beim Interface nicht klar ist welcher genaue Datentyp zurückgegeben werden soll. 
Da hier eine Abhängigkeit von einer konkreten Implementierung anstelle des abstrakten Interfaces besteht ist das Dependency Inversion Principle verletzt.

\begin{figure}[H]
  \centering
  \includesvg[inkscapelatex = false, width = 300pt]{Chapters/Chapter2/negativ}
  \caption{Abhängigkeiten auf die Klasse GPXToTour}
\end{figure}


